using System;
using System.ComponentModel;
using System.Runtime.InteropServices;

namespace EyeCatcher.Native
{
    [System.Security.SuppressUnmanagedCodeSecurity]
    internal static class NativeMethods
    {

        /// <summary>
        /// Gets Thread and Process Id for a window
        /// </summary>
        /// <param name="hWnd">The widnow handle</param>
        /// <param name="processId">The process id</param>
        /// <returns>The thread id</returns>
        [DllImport("user32.dll", SetLastError = true)]
        public static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint processId);

        #region IsWindowVisible

        /// <summary>
        /// If the specified window, its parent window, its parent's parent window, and so forth, have the WS_VISIBLE style, the return value is nonzero. Otherwise, the return value is zero.
        /// </summary>
        /// <param name="hWnd"></param>
        /// <returns>return value specifies whether the window has the WS_VISIBLE style. it may be true even if the window is totally obscured by other windows.</returns>
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool IsWindowVisible(IntPtr hWnd);

        #endregion

        #region IsWindow

        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        public static extern bool IsWindow(IntPtr hwnd);

        #endregion

        #region GetActiveWindow

        [DllImport("user32.dll")]
        public static extern IntPtr GetForegroundWindow();

        #endregion

        #region WinEventHook

        // ReSharper disable once UnusedMember.Global
        public const int CHILDID_SELF = 0;

        /// <summary>
        /// https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nc-winuser-wineventproc
        /// An application-defined callback (or hook) function that the system calls in response to events generated by an accessible object. The hook function processes the event notifications as required. Clients install the hook function and request specific types of event notifications by calling SetWinEventHook.
        /// The WINEVENTPROC type defines a pointer to this callback function. WinEventProc is a placeholder for the application-defined function name.
        /// </summary>
        /// <param name="hWinEventHook">Handle to an event hook function. This value is returned by SetWinEventHook when the hook function is installed and is specific to each instance of the hook function.</param>
        /// <param name="eventType">Event Constant <see cref="EventConstant"/></param>
        /// <param name="hwnd">Handle to the window that generates the event, or NULL if no window is associated with the event. For example, the mouse pointer is not associated with a window.</param>
        /// <param name="idObject">
        /// Identifies the object associated with the event. This is one of the object identifiers or a custom object ID.
        /// <see cref="ObjectIdentifier"/>
        /// </param>
        /// <param name="idChild">
        /// Identifies whether the event was triggered by an object or a child element of the object. 
        /// If this value is CHILDID_SELF, the event was triggered by the object; otherwise, this value is the child ID of the element that triggered the event.
        /// </param>
        /// <param name="dwEventThread"></param>
        /// <param name="dwmsEventTime">Specifies the time, in milliseconds, that the event was generated.</param>
        public delegate void WinEventDelegate(IntPtr hWinEventHook, EventConstant eventType, IntPtr hwnd, ObjectIdentifier idObject, uint idChild, uint dwEventThread, uint dwmsEventTime);

        /// <summary>
        /// Sets an event hook function for a range of events.
        /// </summary>
        /// <param name="eventMin">
        /// Specifies the event constant for the lowest event value in the range of events that are handled by the hook function.
        /// This parameter can be set to EVENT_MIN to indicate the lowest possible event value.
        /// </param>
        /// <param name="eventMax">
        /// Specifies the event constant for the highest event value in the range of events that are handled by the hook function.
        /// This parameter can be set to EVENT_MAX to indicate the highest possible event value.
        /// </param>
        /// <param name="hmodWinEventProc">
        /// Handle to the DLL that contains the hook function at lpfnWinEventProc, if the WINEVENT_INCONTEXT flag is specified in the dwFlags parameter.
        /// If the hook function is not located in a DLL, or if the WINEVENT_OUTOFCONTEXT flag is specified, this parameter is NULL.
        /// </param>
        /// <param name="lpfnWinEventProc">Pointer to the event hook function.</param>
        /// <param name="idProcess">Specifies the ID of the process from which the hook function receives events. Specify zero (0) to receive events from all processes on the current desktop.</param>
        /// <param name="idThread">Specifies the ID of the thread from which the hook function receives events. If this parameter is zero, the hook function is associated with all existing threads on the current desktop.</param>
        /// <param name="dwFlags">Flag values that specify the location of the hook function and of the events to be skipped. </param>
        /// <returns>
        /// If successful, returns an HWINEVENTHOOK value that identifies this event hook instance. Applications save this return value to use it with the UnhookWinEvent function.
        /// If unsuccessful, returns zero.
        /// </returns>
        [DllImport("user32.dll")]
        private static extern IntPtr SetWinEventHook(EventConstant eventMin, EventConstant eventMax, IntPtr hmodWinEventProc, WinEventDelegate lpfnWinEventProc, uint idProcess, uint idThread, WinEventHookFlags dwFlags);

        public static IntPtr SetWinEventHook(EventConstant eventConstant, WinEventDelegate winEventProc, uint processId = 0, uint threadId = 0)
        {
            var windowEventHook = SetWinEventHook(
                eventConstant, // eventMin
                eventConstant, // eventMax
                IntPtr.Zero,  // hmodWinEventProc
                winEventProc,     // lpfnWinEventProc
                processId, // idProcess
                threadId, // idThread
                WinEventHookFlags.WINEVENT_OUTOFCONTEXT | WinEventHookFlags.WINEVENT_SKIPOWNPROCESS);

            if (windowEventHook == IntPtr.Zero)
            {
                throw new Win32Exception(Marshal.GetLastWin32Error());
            }
            return windowEventHook;
        }

        [DllImport("user32.dll")]
        internal static extern bool UnhookWinEvent(IntPtr hWinEventHook);

        #endregion

        #region Clipboard

        [DllImport("User32.dll")]
        public static extern int SetClipboardViewer(IntPtr hWndNewViewer);

        [DllImport("User32.dll", CharSet = CharSet.Auto)]
        public static extern bool ChangeClipboardChain(IntPtr hWndRemove, IntPtr hWndNewNext);

        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        public static extern int SendMessage(IntPtr hwnd, int wMsg, IntPtr wParam, IntPtr lParam);

        #endregion

    }
}
